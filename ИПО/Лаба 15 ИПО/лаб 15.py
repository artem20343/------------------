#импортируеем время, рандом и wraps
import time
import random
from functools import wraps
def timeit(method):#Определение декоратора timeit, который будет определять время выполнения функции
    @wraps(method)#Применение wraps к методу
    def timed(*args, **kw):#Определение внутренней функции timed, которая будет измерять время
        ts = time.monotonic() #Запись текущего времени перед вызовом функции
        result = method(*args, **kw)#Вызов основной функции
        te = time.monotonic()#Запись текущего времени после выполнения функции
        ms = (te - ts) * 1000#Вычисление времени выполнения в миллисекундах
        all_args = ', '.join(tuple(f'{a!r}' for a in args) + tuple(f'{k}={v!r}' for k, v in kw.items()))#Формирование строки с аргументами функции
        print(f'{method.__name__}({all_args}): {ms:2.2f} ms')#Вывод имени функции, аргументов и времени выполнения
        return result#возвращает результат основной функции
    return timed#Возврат внутренней функции timed
@timeit#Применение декоратора timeit к функции sort
def sort(arr):#Aункциz сортировки вставками
    for i in range(1, len(arr)):#Цикл по элементам массива для сортировки
        key = arr[i]#Запоминание текущего элемента
        j = i-1#Установка индекса предыдущего элемента
        while j >=0 and key < arr[j]:#Цикл для сравнения и перемещения элементов
            arr[j+1] = arr[j]#Перемещение элемента вправо
            j -= 1#Переход к предыдущему элементу
        arr[j+1] = key#Вставка ключа в отсортированную часть массива
    return arr#Возврат отсортированного массива
sizes = [10, 100, 1000, 10000, 100000]#Задание размеров массивов
times = []#Создание списка для хранения времени выполнения
for size in sizes:#Цикл по размерам массивов
    arr = [random.randint(0, 100) for j in range(size)]#Генерация массивов
    start_time = time.monotonic()#Запись текущего времени перед сортировкой
    sorted_arr = sort(arr)#Вызов функции сортировки
    end_time = time.monotonic()#Запись текущего времени после сортировки
    time_diff = (end_time - start_time) * 1000#Вычисление времени выполнения в миллисекундах
    times.append(time_diff)#Добавление времени выполнения в список